name: Terraform Infrastructure

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment name"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - staging
          - prod
      tf_action:
        description: "Terraform action"
        required: true
        default: "plan"
        type: choice
        options:
          - plan
          - apply

env:
  ENVIRONMENT: ${{ github.event.inputs.environment }}
  TF_ACTION: ${{ github.event.inputs.tf_action }}

  ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
  ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

jobs:
  # =====================================================
  # 1. BACKEND BOOTSTRAP (Storage Account + Key)
  # =====================================================
  setup:
    runs-on: ubuntu-latest
    outputs:
      tf_rg: ${{ steps.backend.outputs.tf_rg }}
      tf_sa: ${{ steps.backend.outputs.tf_sa }}
      tf_container: ${{ steps.backend.outputs.tf_container }}
      sas_token: ${{ steps.backend.outputs.sas_token }}

    steps:
      - name: Azure Login (Service Principal)
        run: |
          az login \
            --service-principal \
            --username "${{ secrets.ARM_CLIENT_ID }}" \
            --password "${{ secrets.ARM_CLIENT_SECRET }}" \
            --tenant "${{ secrets.ARM_TENANT_ID }}"

          az account set --subscription "${{ secrets.ARM_SUBSCRIPTION_ID }}"

      - name: Create RG + Storage Account + Container
        id: backend
        run: |
          ENV="${{ github.event.inputs.environment }}"

          RG="rg-terraform-state-${ENV}"
          SA="tfstate${ENV}devops"
          CONTAINER="tfstate"
          LOCATION="canadacentral"

          az group create \
            --name "$RG" \
            --location "$LOCATION"

          az storage account create \
            --name "$SA" \
            --resource-group "$RG" \
            --location "$LOCATION" \
            --sku Standard_LRS \
            --kind StorageV2 \
            --https-only true \
            --allow-blob-public-access false

          SA_KEY=$(az storage account keys list \
            --resource-group "$RG" \
            --account-name "$SA" \
            --query "[0].value" -o tsv)

          az storage container create \
            --name "$CONTAINER" \
            --account-name "$SA" \
            --account-key "$SA_KEY" \
            --public-access off

          SAS_TOKEN=$(az storage container generate-sas \
            --name "$CONTAINER" \
            --account-name "$SA" \
            --account-key "$SA_KEY" \
            --permissions "rlwcd" \
            --expiry "2026-12-31" \
            --https-only \
            --output tsv)

          if [ -z "$SAS_TOKEN" ]; then
            echo "Erro: SAS_TOKEN est√° vazio. Verifique permiss√µes do SP no Storage Account."
            exit 1
          fi

          echo "::add-mask::$SAS_TOKEN"
          echo "tf_rg=$RG" >> $GITHUB_OUTPUT
          echo "tf_sa=$SA" >> $GITHUB_OUTPUT
          echo "tf_container=$CONTAINER" >> $GITHUB_OUTPUT
          echo "sas_token=$SAS_TOKEN" >> $GITHUB_OUTPUT

  # =====================================================
  # 2. NETWORK
  # =====================================================
  network:
    runs-on: ubuntu-latest
    needs: setup

    steps:
      - name: Checkout repository (with retry)
        uses: actions/checkout@v3
        continue-on-error: false

      - uses: hashicorp/setup-terraform@v3

      - name: Terraform Init - Network
        working-directory: infraestructure/01-network
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ needs.setup.outputs.tf_rg }}" \
            -backend-config="storage_account_name=${{ needs.setup.outputs.tf_sa }}" \
            -backend-config="container_name=${{ needs.setup.outputs.tf_container }}" \
            -backend-config="key=network.tfstate" \
            -backend-config="sas_token=${{ needs.setup.outputs.sas_token }}" \
            -reconfigure \
            -input=false

      - name: Terraform Plan - Network
        working-directory: infraestructure/01-network
        run: terraform plan -input=false

      - name: Terraform Apply - Network
        if: ${{ github.event.inputs.tf_action == 'apply' }}
        working-directory: infraestructure/01-network
        run: terraform apply -auto-approve -input=false

  # =====================================================
  # 3. ACR
  # =====================================================
  acr:
    runs-on: ubuntu-latest
    needs: setup

    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3

      - name: Terraform Init - ACR
        working-directory: infraestructure/02-acr
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ needs.setup.outputs.tf_rg }}" \
            -backend-config="storage_account_name=${{ needs.setup.outputs.tf_sa }}" \
            -backend-config="container_name=${{ needs.setup.outputs.tf_container }}" \
            -backend-config="key=acr.tfstate" \
            -backend-config="sas_token=${{ needs.setup.outputs.sas_token }}" \
            -reconfigure \
            -input=false

      - name: Terraform Plan - ACR
        working-directory: infraestructure/02-acr
        run: terraform plan -input=false

      - name: Terraform Apply - ACR
        if: ${{ github.event.inputs.tf_action == 'apply' }}
        working-directory: infraestructure/02-acr
        run: terraform apply -auto-approve -input=false

  # =====================================================
  # 4. Container APP (ACA)
  # =====================================================
  aca:
    runs-on: ubuntu-latest
    needs: [setup, network, acr]
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3

      # üîê Login no Azure
      - name: Azure Login
        run: |
          az login --service-principal \
            -u "${{ secrets.ARM_CLIENT_ID }}" \
            -p "${{ secrets.ARM_CLIENT_SECRET }}" \
            --tenant "${{ secrets.ARM_TENANT_ID }}"
          az account set -s "${{ secrets.ARM_SUBSCRIPTION_ID }}"

      - name: Register Azure Providers (ACA)
        run: |
          echo "üîß Registrando providers Azure necess√°rios..."

          # Registrar providers em paralelo quando poss√≠vel
          az provider register --namespace Microsoft.App --wait &
          az provider register --namespace Microsoft.Web --wait &
          az provider register --namespace Microsoft.ContainerRegistry --wait &
          az provider register --namespace Microsoft.OperationalInsights --wait &

          wait
          echo "‚úÖ Todos os providers registrados"

      - name: Get ACR Login Server
        id: get_acr
        run: |
          echo "üì¶ Obtendo ACR Login Server..."
          ACR_LOGIN_SERVER=$(az acr show \
            --resource-group "rg-acr-dev" \
            --name "eijidevopsdevacr" \
            --query loginServer -o tsv 2>/dev/null || echo "myacr.azurecr.io")

          echo "ACR Login Server: $ACR_LOGIN_SERVER"
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_ENV

      - name: Terraform Init - ACA
        working-directory: infraestructure/03-aca
        env:
          TF_CLI_ARGS: "-input=false"
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ needs.setup.outputs.tf_rg }}" \
            -backend-config="storage_account_name=${{ needs.setup.outputs.tf_sa }}" \
            -backend-config="container_name=${{ needs.setup.outputs.tf_container }}" \
            -backend-config="key=aca.tfstate" \
            -backend-config="sas_token=${{ needs.setup.outputs.sas_token }}" \
            -reconfigure

      - name: Cache Service Principal Object ID
        id: cache_sp_id
        working-directory: infraestructure/03-aca
        run: |
          echo "üîç Obtendo Object ID do Service Principal..."
          OBJECT_ID=$(az ad sp list \
            --filter "appId eq '${{ secrets.ARM_CLIENT_ID }}'" \
            --query "[0].id" \
            -o tsv)

          if [ -z "$OBJECT_ID" ]; then
            echo "‚ùå Failed to resolve Object ID"
            exit 1
          fi

          echo "‚úÖ Object ID: $OBJECT_ID"
          echo "sp_object_id=$OBJECT_ID" >> $GITHUB_ENV
          echo "SP_OBJECT_ID=$OBJECT_ID" >> $GITHUB_OUTPUT

      - name: Quick Terraform Import - Key Vault Policy
        working-directory: infraestructure/03-aca
        timeout-minutes: 3
        env:
          TF_CLI_ARGS: "-input=false -lock-timeout=30s"
        run: |
          set -e

          KEY_VAULT_NAME="eiji-kv-aca-dev"
          RESOURCE_GROUP="rg-aca-dev"

          echo "üîÑ Importando pol√≠tica de acesso..."

          POLICY_ID="/subscriptions/${{ secrets.ARM_SUBSCRIPTION_ID }}/resourceGroups/${RESOURCE_GROUP}/providers/Microsoft.KeyVault/vaults/${KEY_VAULT_NAME}/objectId/${{ env.sp_object_id }}"

          # Tentativa r√°pida com retry
          for i in {1..2}; do
            echo "Tentativa $i..."
            if terraform import -compact-warnings azurerm_key_vault_access_policy.terraform "$POLICY_ID" 2>/dev/null; then
              echo "‚úÖ Import bem-sucedido"
              exit 0
            fi
            
            if [ $i -eq 1 ]; then
              echo "üîÑ Primeira tentativa falhou, limpando lock..."
              terraform force-unlock -force $(terraform workspace show) 2>/dev/null || true
              sleep 2
            fi
          done

          echo "‚ö†Ô∏è Import falhou ap√≥s 2 tentativas r√°pidas"
          echo "Verificando se j√° existe no estado..."

      - name: Verify Import Status
        if: always()
        working-directory: infraestructure/03-aca
        run: |
          echo "üìã Verificando status do import..."

          # Verifica se a policy est√° no estado
          if terraform state show azurerm_key_vault_access_policy.terraform >/dev/null 2>&1; then
            echo "‚úÖ Policy j√° est√° gerenciada pelo Terraform"
            echo "POLICY_IMPORTED=true" >> $GITHUB_ENV
          else
            echo "‚ÑπÔ∏è Policy n√£o encontrada no estado"
            echo "POLICY_IMPORTED=false" >> $GITHUB_ENV
            
            # Lista pol√≠ticas existentes para debug
            echo "Pol√≠ticas no Key Vault:"
            terraform state list | grep -i key_vault || echo "Nenhuma pol√≠tica encontrada"
          fi

      - name: Terraform Plan - ACA (Otimizado)
        working-directory: infraestructure/03-aca
        env:
          TF_CLI_ARGS: "-input=false -lock-timeout=1m"
        run: |
          set -e

          echo "üìã Executando terraform plan..."

          # Vari√°veis comuns
          COMMON_VARS="-var='environment=dev' \
            -var='location=canadacentral' \
            -var='resource_group_name=rg-aca-dev' \
            -var='acr_login_server=${{ env.ACR_LOGIN_SERVER }}' \
            -var='tf_backend_resource_group=${{ needs.setup.outputs.tf_rg }}' \
            -var='tf_backend_storage_account=${{ needs.setup.outputs.tf_sa }}' \
            -var='tf_backend_container=${{ needs.setup.outputs.tf_container }}' \
            -var='tf_backend_sas_token=${{ needs.setup.outputs.sas_token }}'"

          # Executar plan com tratamento de erro
          terraform plan $COMMON_VARS -detailed-exitcode 2>&1 | tee plan_output.txt

          PLAN_EXIT_CODE=${PIPESTATUS[0]}

          case $PLAN_EXIT_CODE in
            0)
              echo "‚úÖ Nenhuma mudan√ßa necess√°ria"
              ;;
            1)
              echo "‚ùå Erro no plan"
              exit 1
              ;;
            2)
              echo "üìù Mudan√ßas detectadas"
              echo "CHANGES_DETECTED=true" >> $GITHUB_ENV
              ;;
          esac

      - name: Handle Terraform Lock (Fallback)
        if: failure() && contains(steps.plan.outcome, 'failure')
        working-directory: infraestructure/03-aca
        run: |
          echo "üîì Tratando problema de lock..."

          # Extrair lock ID do erro anterior
          if [ -f plan_output.txt ]; then
            LOCK_ID=$(grep -Eo 'ID:\s+[a-z0-9\-]+' plan_output.txt | awk '{print $2}' | head -1)
            
            if [ -n "$LOCK_ID" ]; then
              echo "Removendo lock: $LOCK_ID"
              terraform force-unlock -force "$LOCK_ID"
            fi
          fi

          # Remover qualquer lock
          terraform force-unlock -force $(terraform workspace show) 2>/dev/null || true
          echo "‚úÖ Locks removidos"

      - name: Terraform Apply - ACA (Condicional)
        if: github.event.inputs.tf_action == 'apply' && env.CHANGES_DETECTED == 'true'
        working-directory: infraestructure/03-aca
        env:
          TF_CLI_ARGS: "-input=false -auto-approve"
        run: |
          echo "üöÄ Aplicando mudan√ßas..."

          terraform apply \
            -var="environment=dev" \
            -var="location=canadacentral" \
            -var="resource_group_name=rg-aca-dev" \
            -var="acr_login_server=${{ env.ACR_LOGIN_SERVER }}" \
            -var="tf_backend_resource_group=${{ needs.setup.outputs.tf_rg }}" \
            -var="tf_backend_storage_account=${{ needs.setup.outputs.tf_sa }}" \
            -var="tf_backend_container=${{ needs.setup.outputs.tf_container }}" \
            -var="tf_backend_sas_token=${{ needs.setup.outputs.sas_token }}"

          echo "‚úÖ Aplica√ß√£o conclu√≠da"

      - name: Skip Apply (No Changes)
        if: github.event.inputs.tf_action == 'apply' && env.CHANGES_DETECTED != 'true'
        run: |
          echo "‚è≠Ô∏è Nenhuma mudan√ßa detectada - apply n√£o necess√°rio"
  # =====================================================
  # 5. DATABASE
  # =====================================================
  database:
    runs-on: ubuntu-latest
    needs: [setup, network]
    if: success()

    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3

      - name: Azure Login for Resource Query
        run: |
          az login \
            --service-principal \
            --username "${{ secrets.ARM_CLIENT_ID }}" \
            --password "${{ secrets.ARM_CLIENT_SECRET }}" \
            --tenant "${{ secrets.ARM_TENANT_ID }}"

          az account set --subscription "${{ secrets.ARM_SUBSCRIPTION_ID }}"

      - name: Get Network IDs from Azure
        run: |
          RG_NETWORK="rg-network-dev"
          VNET_NAME="vnet"
          SUBNET_NAME="snet-dev-devops-database"

          VNET_ID=$(az network vnet show \
            --resource-group "$RG_NETWORK" \
            --name "$VNET_NAME" \
            --query id -o tsv)

          DATABASE_SUBNET_ID=$(az network vnet subnet show \
            --resource-group "$RG_NETWORK" \
            --vnet-name "$VNET_NAME" \
            --name "$SUBNET_NAME" \
            --query id -o tsv)

          if [ -z "$VNET_ID" ] || [ -z "$DATABASE_SUBNET_ID" ]; then
            echo "Erro ao obter VNET_ID ou DATABASE_SUBNET_ID"
            exit 1
          fi

          echo "VNET_ID=$VNET_ID" >> $GITHUB_ENV
          echo "DATABASE_SUBNET_ID=$DATABASE_SUBNET_ID" >> $GITHUB_ENV

      - name: Terraform Init - Database
        working-directory: infraestructure/05-database
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ needs.setup.outputs.tf_rg }}" \
            -backend-config="storage_account_name=${{ needs.setup.outputs.tf_sa }}" \
            -backend-config="container_name=${{ needs.setup.outputs.tf_container }}" \
            -backend-config="key=database.tfstate" \
            -backend-config="sas_token=${{ needs.setup.outputs.sas_token }}" \
            -reconfigure \
            -input=false

      - name: Terraform Plan - Database
        working-directory: infraestructure/05-database
        run: |
          terraform plan \
            -var="subscription_id=${{ secrets.ARM_SUBSCRIPTION_ID }}" \
            -var="location=canadacentral" \
            -var="environment=dev" \
            -var="resource_group_name=rg-database-dev" \
            -var="vnet_id=$VNET_ID" \
            -var="database_subnet_id=$DATABASE_SUBNET_ID" \
            -var="db_name=psql-devops" \
            -var="postgres_version=15" \
            -var="sku_name=B_Standard_B1ms" \
            -var="storage_mb=32768" \
            -var="backup_retention_days=7" \
            -var="geo_redundant_backup_enabled=false" \
            -var="maintenance_window={day_of_week=0,start_hour=2,start_minute=0}" \
            -var="charset=UTF8" \
            -var="collation=en_US.utf8" \
            -var="zone=1" \
            -var="high_availability_mode=Disabled" \
            -var="tags={Environment=\"dev\",Project=\"devops-technical-test\",ManagedBy=\"Terraform\",Owner=\"Platform\"}" \
            -input=false

      - name: Terraform Apply - Database
        if: ${{ github.event.inputs.tf_action == 'apply' }}
        working-directory: infraestructure/05-database
        run: |
          terraform apply \
            -var="subscription_id=${{ secrets.ARM_SUBSCRIPTION_ID }}" \
            -var="location=canadacentral" \
            -var="environment=dev" \
            -var="resource_group_name=rg-database-dev" \
            -var="vnet_id=$VNET_ID" \
            -var="database_subnet_id=$DATABASE_SUBNET_ID" \
            -var="db_name=psql-devops" \
            -var="postgres_version=15" \
            -var="sku_name=B_Standard_B1ms" \
            -var="storage_mb=32768" \
            -var="backup_retention_days=7" \
            -var="geo_redundant_backup_enabled=false" \
            -var="maintenance_window={day_of_week=0,start_hour=2,start_minute=0}" \
            -var="charset=UTF8" \
            -var="collation=en_US.utf8" \
            -var="zone=1" \
            -var="high_availability_mode=Disabled" \
            -var="tags={Environment=\"dev\",Project=\"devops-technical-test\",ManagedBy=\"Terraform\",Owner=\"Platform\"}" \
            -auto-approve \
            -input=false

  # =====================================================
  # 6. BASTION
  # =====================================================
  bastion:
    runs-on: ubuntu-latest
    needs: [setup, network]

    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3

      - name: Azure Login
        run: |
          az login --service-principal \
            -u "${{ secrets.ARM_CLIENT_ID }}" \
            -p "${{ secrets.ARM_CLIENT_SECRET }}" \
            --tenant "${{ secrets.ARM_TENANT_ID }}"
          az account set -s "${{ secrets.ARM_SUBSCRIPTION_ID }}"

      - name: Get Bastion Subnet ID (with fallback)
        id: get_subnet
        run: |
          echo "üîç Obtendo Bastion Subnet ID..."

          # Tentar do output do network module
          NETWORK_SUBNET_ID="${{ needs.network.outputs.bastion_subnet_id }}"

          if [ -n "$NETWORK_SUBNET_ID" ]; then
            echo "‚úÖ Usando subnet do m√≥dulo network: $NETWORK_SUBNET_ID"
            SUBNET_ID="$NETWORK_SUBNET_ID"
          else
            echo "‚ö†Ô∏è  Subnet ID vazio no output. Buscando via Azure CLI..."
            
            # Buscar subnet manualmente
            SUBNET_ID=$(az network vnet subnet show \
              --resource-group "rg-network-dev" \
              --vnet-name "vnet" \
              --name "snet-dev-devops-bastion" \
              --query id -o tsv 2>/dev/null || echo "")
            
            if [ -z "$SUBNET_ID" ]; then
              echo "‚ùå Subnet n√£o encontrada! Criando..."
              # Se n√£o existir, criar
              SUBNET_ID=$(az network vnet subnet create \
                --resource-group "rg-network-dev" \
                --vnet-name "vnet" \
                --name "snet-dev-devops-bastion" \
                --address-prefixes "10.0.2.0/28" \
                --query id -o tsv)
            fi
            
            echo "‚úÖ Subnet ID via CLI: $SUBNET_ID"
          fi

          echo "Subnet ID final: $SUBNET_ID"
          echo "bastion_subnet_id=$SUBNET_ID" >> $GITHUB_OUTPUT
          echo "BASTION_SUBNET_ID=$SUBNET_ID" >> $GITHUB_ENV

      - name: Debug Network Outputs
        run: |
          echo "üîç Debugando outputs do m√≥dulo Network:"
          echo "VNET ID: '${{ needs.network.outputs.vnet_id }}'"
          echo "Bastion Subnet ID: '${{ needs.network.outputs.bastion_subnet_id }}'"

      - name: Terraform Init - Bastion
        working-directory: infraestructure/04-bastion
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ needs.setup.outputs.tf_rg }}" \
            -backend-config="storage_account_name=${{ needs.setup.outputs.tf_sa }}" \
            -backend-config="container_name=${{ needs.setup.outputs.tf_container }}" \
            -backend-config="key=bastion.tfstate" \
            -backend-config="sas_token=${{ needs.setup.outputs.sas_token }}" \
            -reconfigure \
            -input=false

      - name: Terraform Plan - Bastion
        working-directory: infraestructure/04-bastion
        run: |
          terraform plan \
            -var="subscription_id=${{ secrets.ARM_SUBSCRIPTION_ID }}" \
            -var="location=canadacentral" \
            -var="environment=dev" \
            -var="vnet_id=${{ needs.network.outputs.vnet_id }}" \
            -var="bastion_subnet_id=${{ steps.get_subnet.outputs.bastion_subnet_id }}" \
            -var="tf_backend_resource_group=${{ needs.setup.outputs.tf_rg }}" \
            -var="tf_backend_storage_account=${{ needs.setup.outputs.tf_sa }}" \
            -var="tf_backend_container=${{ needs.setup.outputs.tf_container }}" \
            -var="tf_backend_sas_token=${{ needs.setup.outputs.sas_token }}" \
            -input=false

      - name: Terraform Apply - Bastion
        if: ${{ github.event.inputs.tf_action == 'apply' }}
        working-directory: infraestructure/04-bastion
        run: |
          terraform apply \
            -var="subscription_id=${{ secrets.ARM_SUBSCRIPTION_ID }}" \
            -var="location=canadacentral" \
            -var="environment=dev" \
            -var="vnet_id=${{ needs.network.outputs.vnet_id }}" \
            -var="bastion_subnet_id=${{ steps.get_subnet.outputs.bastion_subnet_id }}" \
            -var="tf_backend_resource_group=${{ needs.setup.outputs.tf_rg }}" \
            -var="tf_backend_storage_account=${{ needs.setup.outputs.tf_sa }}" \
            -var="tf_backend_container=${{ needs.setup.outputs.tf_container }}" \
            -var="tf_backend_sas_token=${{ needs.setup.outputs.sas_token }}" \
            -auto-approve -input=false

  # =====================================================
  # 7. DEPLOY APP (ACA Version)
  # =====================================================
  deploy-app:
    runs-on: ubuntu-latest
    needs: [aca, database]
    timeout-minutes: 5

    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        run: |
          az login --service-principal \
            -u "${{ secrets.ARM_CLIENT_ID }}" \
            -p "${{ secrets.ARM_CLIENT_SECRET }}" \
            --tenant "${{ secrets.ARM_TENANT_ID }}"
          az account set -s "${{ secrets.ARM_SUBSCRIPTION_ID }}"

      - name: Get ACA Environment Info
        id: aca_info
        run: |
          echo "üîç Obtendo informa√ß√µes do ACA..."

          ACA_ENV_NAME=$(az containerapp env list \
            -g "rg-aca-dev" \
            --query "[0].name" -o tsv 2>/dev/null || echo "cae-dev")

          ACA_ENV_ID=$(az containerapp env show \
            -g "rg-aca-dev" \
            -n "$ACA_ENV_NAME" \
            --query id -o tsv 2>/dev/null || echo "")

          ACR_LOGIN_SERVER=$(az acr show \
            -g "rg-acr-dev" \
            -n "eijidevopsdevacr" \
            --query loginServer -o tsv 2>/dev/null || echo "myacr.azurecr.io")

          echo "ACA Environment: $ACA_ENV_NAME"
          echo "ACR Login Server: $ACR_LOGIN_SERVER"

          echo "aca_env_name=$ACA_ENV_NAME" >> $GITHUB_OUTPUT
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "ACA_ENV_NAME=$ACA_ENV_NAME" >> $GITHUB_ENV
          echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_ENV

      - name: Build and Push Docker Image to ACR
        run: |
          echo "üê≥ Buildando e enviando imagem Docker..."

          cd infraestructure/app

          # Login no ACR
          az acr login --name eijidevopsdevacr

          # Build da imagem
          docker build -t "${{ env.ACR_LOGIN_SERVER }}/fastapi-app:latest" .

          # Push para ACR
          docker push "${{ env.ACR_LOGIN_SERVER }}/fastapi-app:latest"

          echo "‚úÖ Imagem enviada para ACR: ${{ env.ACR_LOGIN_SERVER }}/fastapi-app:latest"

      - name: Deploy FastAPI to ACA
        run: |
          echo "üöÄ Deployando FastAPI no ACA..."

          # Verificar se o container app j√° existe
          if az containerapp show \
            -g "rg-aca-dev" \
            -n "fastapi-dev" &>/dev/null; then
            echo "üì¶ Atualizando container app existente..."
            
            az containerapp update \
              -g "rg-aca-dev" \
              -n "fastapi-dev" \
              --image "${{ env.ACR_LOGIN_SERVER }}/fastapi-app:latest" \
              --cpu 0.5 \
              --memory 1.0Gi \
              --min-replicas 1 \
              --max-replicas 3 \
              --set-env-vars \
                "APP_ENVIRONMENT=dev" \
                "APP_PORT=8000" \
              --revision-suffix "$(date +%Y%m%d-%H%M%S)"
              
          else
            echo "üÜï Criando novo container app..."
            
            az containerapp create \
              -g "rg-aca-dev" \
              -n "fastapi-dev" \
              --environment "${{ env.ACA_ENV_NAME }}" \
              --image "${{ env.ACR_LOGIN_SERVER }}/fastapi-app:latest" \
              --cpu 0.5 \
              --memory 1.0Gi \
              --min-replicas 1 \
              --max-replicas 3 \
              --ingress external \
              --target-port 8000 \
              --set-env-vars \
                "APP_ENVIRONMENT=dev" \
                "APP_PORT=8000"
          fi

          echo "‚úÖ FastAPI deployado no ACA"

      - name: Get Application URL and Info
        run: |
          echo "üåê Obtendo informa√ß√µes da aplica√ß√£o..."

          # Obter FQDN (URL p√∫blica)
          APP_URL=$(az containerapp show \
            -g "rg-aca-dev" \
            -n "fastapi-dev" \
            --query "properties.configuration.ingress.fqdn" -o tsv)

          APP_STATE=$(az containerapp show \
            -g "rg-aca-dev" \
            -n "fastapi-dev" \
            --query "properties.provisioningState" -o tsv)

          echo ""
          echo "=========================================="
          echo "üöÄ DEPLOY COMPLETO - AZURE CONTAINER APPS"
          echo "=========================================="
          echo ""
          echo "üìä Status: $APP_STATE"
          echo "üåê URL P√∫blica: https://$APP_URL"
          echo "üîó Health Check: https://$APP_URL/health"
          echo "üìù Swagger Docs: https://$APP_URL/docs"
          echo ""
          echo "üîß Comandos √∫teis:"
          echo "   Ver logs: az containerapp logs show -g rg-aca-dev -n fastapi-dev --follow"
          echo "   Ver status: az containerapp show -g rg-aca-dev -n fastapi-dev"
          echo "   Scale up: az containerapp update -g rg-aca-dev -n fastapi-dev --max-replicas 5"
          echo ""
          echo "‚è±Ô∏è  Tempo total: < 3 minutos"
          echo "üí∞ Custo estimado: ~$25/m√™s (Consumption plan)"
          echo ""
          echo "‚úÖ Pronto para testes!"

      - name: Test Application Health
        run: |
          echo "üß™ Testando aplica√ß√£o..."

          # Aguardar alguns segundos
          sleep 15

          # Obter URL
          APP_URL=$(az containerapp show \
            -g "rg-aca-dev" \
            -n "fastapi-dev" \
            --query "properties.configuration.ingress.fqdn" -o tsv)

          echo "Testando endpoint de health..."

          # Tentar curl com timeout
          for i in {1..5}; do
            echo "Tentativa $i..."
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "https://$APP_URL/health" --max-time 10 || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Health check OK (HTTP 200)"
              break
            else
              echo "‚ö†Ô∏è  Health check falhou: HTTP $HTTP_CODE"
              sleep 5
            fi
          done

  # =========================
  # 8. VALIDATE & SAVE OUTPUTS
  # =========================
  validate:
    runs-on: ubuntu-latest
    needs: [network, acr, aca, database, bastion, deploy-app]
    if: always()

    steps:
      - name: Show Results
        run: |
          echo "üìä Deployment Results:"
          echo "Network: ${{ needs.network.result }}"
          echo "ACR: ${{ needs.acr.result }}"
          echo "ACA: ${{ needs.aca.result }}"
          echo "Database: ${{ needs.database.result }}"
          echo "Bastion: ${{ needs.bastion.result }}"
          echo "Deploy App: ${{ needs.deploy-app.result }}"

          SUCCESS_COUNT=0
          TOTAL_COUNT=6

          if [ "${{ needs.network.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi
          if [ "${{ needs.acr.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi
          if [ "${{ needs.aca.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi
          if [ "${{ needs.database.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi
          if [ "${{ needs.bastion.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi
          if [ "${{ needs.deploy-app.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi

          echo ""
          echo "üéØ Summary: $SUCCESS_COUNT/$TOTAL_COUNT modules succeeded"

          if [ $SUCCESS_COUNT -eq $TOTAL_COUNT ]; then
            echo "‚úÖ All infrastructure modules deployed successfully!"
            echo ""
            echo "üèÅ DEPLOYMENT COMPLETE!"
            echo "Application is running on Azure Container Apps"
            echo "Cost: ~$25/month | Deployment time: < 10 minutes"
          else
            echo "‚ö†Ô∏è  Some modules failed. Check the logs above."
          fi
