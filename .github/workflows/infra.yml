name: Terraform Infrastructure

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment name"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - staging
          - prod
      tf_action:
        description: "Terraform action"
        required: true
        default: "plan"
        type: choice
        options:
          - plan
          - apply

env:
  ENVIRONMENT: ${{ github.event.inputs.environment }}
  TF_ACTION: ${{ github.event.inputs.tf_action }}

  ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
  ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

jobs:
  # =====================================================
  # 1. BACKEND BOOTSTRAP (Storage Account + Key)
  # =====================================================
  setup:
    runs-on: ubuntu-latest
    outputs:
      tf_rg: ${{ steps.backend.outputs.tf_rg }}
      tf_sa: ${{ steps.backend.outputs.tf_sa }}
      tf_container: ${{ steps.backend.outputs.tf_container }}
      sas_token: ${{ steps.backend.outputs.sas_token }}

    steps:
      - name: Azure Login (Service Principal)
        run: |
          az login \
            --service-principal \
            --username "${{ secrets.ARM_CLIENT_ID }}" \
            --password "${{ secrets.ARM_CLIENT_SECRET }}" \
            --tenant "${{ secrets.ARM_TENANT_ID }}"

          az account set --subscription "${{ secrets.ARM_SUBSCRIPTION_ID }}"

      - name: Create RG + Storage Account + Container
        id: backend
        run: |
          ENV="${{ github.event.inputs.environment }}"

          RG="rg-terraform-state-${ENV}"
          SA="tfstate${ENV}devops"
          CONTAINER="tfstate"
          LOCATION="canadacentral"

          az group create \
            --name "$RG" \
            --location "$LOCATION"

          az storage account create \
            --name "$SA" \
            --resource-group "$RG" \
            --location "$LOCATION" \
            --sku Standard_LRS \
            --kind StorageV2 \
            --https-only true \
            --allow-blob-public-access false            

          SA_KEY=$(az storage account keys list \
            --resource-group "$RG" \
            --account-name "$SA" \
            --query "[0].value" -o tsv)

          az storage container create \
            --name "$CONTAINER" \
            --account-name "$SA" \
            --account-key "$SA_KEY" \
            --public-access off

          SAS_TOKEN=$(az storage container generate-sas \
            --name "$CONTAINER" \
            --account-name "$SA" \
            --account-key "$SA_KEY" \
            --permissions "rlwcd" \
            --expiry "2026-12-31" \
            --https-only \
            --output tsv)

          if [ -z "$SAS_TOKEN" ]; then
            echo "Erro: SAS_TOKEN est√° vazio. Verifique permiss√µes do SP no Storage Account."
            exit 1
          fi

          echo "::add-mask::$SAS_TOKEN"
          echo "tf_rg=$RG" >> $GITHUB_OUTPUT
          echo "tf_sa=$SA" >> $GITHUB_OUTPUT
          echo "tf_container=$CONTAINER" >> $GITHUB_OUTPUT
          echo "sas_token=$SAS_TOKEN" >> $GITHUB_OUTPUT

  # =====================================================
  # 2. NETWORK
  # =====================================================
  network:
    runs-on: ubuntu-latest
    needs: setup

    steps:
      - name: Checkout repository (with retry)
        uses: actions/checkout@v3
        continue-on-error: false

      - uses: hashicorp/setup-terraform@v3

      - name: Terraform Init - Network
        working-directory: infraestructure/01-network
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ needs.setup.outputs.tf_rg }}" \
            -backend-config="storage_account_name=${{ needs.setup.outputs.tf_sa }}" \
            -backend-config="container_name=${{ needs.setup.outputs.tf_container }}" \
            -backend-config="key=network.tfstate" \
            -backend-config="sas_token=${{ needs.setup.outputs.sas_token }}" \
            -reconfigure \
            -input=false

      - name: Terraform Plan - Network
        working-directory: infraestructure/01-network
        run: terraform plan -input=false

      - name: Terraform Apply - Network
        if: ${{ github.event.inputs.tf_action == 'apply' }}
        working-directory: infraestructure/01-network
        run: terraform apply -auto-approve -input=false

  # =====================================================
  # 3. ACR
  # =====================================================
  acr:
    runs-on: ubuntu-latest
    needs: setup

    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3

      - name: Terraform Init - ACR
        working-directory: infraestructure/02-acr
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ needs.setup.outputs.tf_rg }}" \
            -backend-config="storage_account_name=${{ needs.setup.outputs.tf_sa }}" \
            -backend-config="container_name=${{ needs.setup.outputs.tf_container }}" \
            -backend-config="key=acr.tfstate" \
            -backend-config="sas_token=${{ needs.setup.outputs.sas_token }}" \
            -reconfigure \
            -input=false

      - name: Terraform Plan - ACR
        working-directory: infraestructure/02-acr
        run: terraform plan -input=false

      - name: Terraform Apply - ACR
        if: ${{ github.event.inputs.tf_action == 'apply' }}
        working-directory: infraestructure/02-acr
        run: terraform apply -auto-approve -input=false

  # =====================================================
  # 4. Container APP (ACA)
  # =====================================================
  aca:
    runs-on: ubuntu-latest
    needs: [setup, network, acr]
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3

      # üîê Login no Azure
      - name: Azure Login
        run: |
          az login --service-principal \
            -u "${{ secrets.ARM_CLIENT_ID }}" \
            -p "${{ secrets.ARM_CLIENT_SECRET }}" \
            --tenant "${{ secrets.ARM_TENANT_ID }}"
          az account set -s "${{ secrets.ARM_SUBSCRIPTION_ID }}"

      - name: Register Azure Providers (ACA)
        run: |
          echo "üîß Registrando providers Azure necess√°rios..."

          # Registrar providers em paralelo quando poss√≠vel
          az provider register --namespace Microsoft.App --wait &
          az provider register --namespace Microsoft.Web --wait &
          az provider register --namespace Microsoft.ContainerRegistry --wait &
          az provider register --namespace Microsoft.OperationalInsights --wait &

          wait
          echo "‚úÖ Todos os providers registrados"

      - name: Get ACR Login Server
        id: get_acr
        run: |
          echo "üì¶ Obtendo ACR Login Server..."
          ACR_LOGIN_SERVER=$(az acr show \
            --resource-group "rg-acr-dev" \
            --name "eijidevopsdevacr" \
            --query loginServer -o tsv 2>/dev/null || echo "myacr.azurecr.io")

          echo "ACR Login Server: $ACR_LOGIN_SERVER"
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_ENV

      - name: Clean Terraform Locks Before Init
        working-directory: infraestructure/03-aca
        run: |
          echo "üîì Limpando locks do Terraform antes do init..."
          # Remove diret√≥rio de lock local se existir
          rm -rf .terraform.tfstate.lock.info 2>/dev/null || true

          # Se usar backend remoto, tenta for√ßar unlock
          terraform force-unlock -force 2>/dev/null || true

          echo "‚úÖ Locks limpos"

      - name: Terraform Init - ACA
        working-directory: infraestructure/03-aca
        env:
          TF_CLI_ARGS: "-input=false"
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ needs.setup.outputs.tf_rg }}" \
            -backend-config="storage_account_name=${{ needs.setup.outputs.tf_sa }}" \
            -backend-config="container_name=${{ needs.setup.outputs.tf_container }}" \
            -backend-config="key=aca.tfstate" \
            -backend-config="sas_token=${{ needs.setup.outputs.sas_token }}" \
            -reconfigure

      - name: Cache Service Principal Object ID
        id: cache_sp_id
        working-directory: infraestructure/03-aca
        run: |
          echo "üîç Obtendo Object ID do Service Principal..."
          OBJECT_ID=$(az ad sp list \
            --filter "appId eq '${{ secrets.ARM_CLIENT_ID }}'" \
            --query "[0].id" \
            -o tsv)

          if [ -z "$OBJECT_ID" ]; then
            echo "‚ùå Failed to resolve Object ID"
            exit 1
          fi

          echo "‚úÖ Object ID: $OBJECT_ID"
          echo "sp_object_id=$OBJECT_ID" >> $GITHUB_ENV
          echo "SP_OBJECT_ID=$OBJECT_ID" >> $GITHUB_OUTPUT

      - name: Clean Terraform State Locks
        working-directory: infraestructure/03-aca
        run: |
          echo "üîì Limpando locks do estado antes do import..."

          # Lista todos os workspaces e remove locks
          for workspace in $(terraform workspace list 2>/dev/null | grep -v "\*" | tr -d '* '); do
            echo "Limpando lock do workspace: $workspace"
            terraform workspace select "$workspace" 2>/dev/null || true
            terraform force-unlock -force 2>/dev/null || true
          done

          # Volta para workspace padr√£o
          terraform workspace select default 2>/dev/null || true

          # For√ßa remo√ß√£o de qualquer lock
          terraform force-unlock -force 2>/dev/null || true

          echo "‚úÖ Locks removidos"

      - name: Quick Terraform Import - Key Vault Policy
        working-directory: infraestructure/03-aca
        timeout-minutes: 3
        env:
          TF_CLI_ARGS: "-input=false -lock-timeout=30s"
        run: |
          set -e

          KEY_VAULT_NAME="eiji-kv-aca-dev"
          RESOURCE_GROUP="rg-aca-dev"

          echo "üîÑ Importando pol√≠tica de acesso..."

          POLICY_ID="/subscriptions/${{ secrets.ARM_SUBSCRIPTION_ID }}/resourceGroups/${RESOURCE_GROUP}/providers/Microsoft.KeyVault/vaults/${KEY_VAULT_NAME}/objectId/${{ env.sp_object_id }}"

          echo "Policy ID: $POLICY_ID"

          # Primeiro verifica se j√° existe (r√°pido)
          if terraform state show azurerm_key_vault_access_policy.terraform >/dev/null 2>&1; then
            echo "‚úÖ Policy j√° est√° no estado - pulando import"
            exit 0
          fi

          # Tentativa r√°pida com lock-timeout curto
          echo "Executando import..."
          terraform import -lock-timeout=30s -input=false -compact-warnings azurerm_key_vault_access_policy.terraform "$POLICY_ID"

          echo "‚úÖ Import conclu√≠do"

      - name: Verify Import and Clean Locks
        if: always()
        working-directory: infraestructure/03-aca
        run: |
          echo "üìã Verificando status do import..."

          # Garante que n√£o h√° locks pendentes
          terraform force-unlock -force 2>/dev/null || true

          # Verifica se a policy est√° no estado
          if terraform state show azurerm_key_vault_access_policy.terraform >/dev/null 2>&1; then
            echo "‚úÖ Policy importada com sucesso"
            echo "POLICY_IMPORTED=true" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è Policy n√£o encontrada no estado"
            echo "POLICY_IMPORTED=false" >> $GITHUB_ENV
          fi

          # Lista recursos para debug
          echo "Recursos no estado:"
          terraform state list | head -10 || echo "Estado vazio ou erro"

      - name: Clean Locks Before Plan
        working-directory: infraestructure/03-aca
        run: |
          echo "üîì Limpando locks antes do plan..."

          # M√©todo agressivo para garantir estado limpo
          echo "1. Removendo locks remotos..."
          terraform force-unlock -force 2>/dev/null || true

          echo "2. Removendo arquivos de lock locais..."
          find . -name "*.lock*" -delete 2>/dev/null || true
          rm -rf .terraform.lock.hcl 2>/dev/null || true

          echo "3. Verificando workspaces..."
          CURRENT_WS=$(terraform workspace show)
          echo "Workspace atual: $CURRENT_WS"

          echo "‚úÖ Estado preparado para plan"

      - name: Get Subnet ID from Network Module
        working-directory: infraestructure/03-aca
        run: |
          echo "üîó Obtendo Subnet ID do m√≥dulo de rede..."

          # Se o estado do network estiver dispon√≠vel, podemos obter a subnet
          # Caso contr√°rio, usaremos um valor padr√£o ou vazio
          ACA_SUBNET_ID=""

          # Tenta obter do estado do terraform (se o m√≥dulo network j√° foi aplicado)
          if terraform state show module.network 2>/dev/null | grep -q "id.*subnets/aca"; then
            ACA_SUBNET_ID=$(terraform state show module.network 2>/dev/null | grep -o 'id.*subnets/aca[^"]*' | head -1 | cut -d'"' -f2)
            echo "‚úÖ Subnet ID encontrada: $ACA_SUBNET_ID"
          else
            echo "‚ö†Ô∏è Subnet ID n√£o encontrada no estado. Usando valor padr√£o/vazio."
          fi

          echo "ACA_SUBNET_ID=$ACA_SUBNET_ID" >> $GITHUB_ENV

      - name: Terraform Plan - ACA (Com Tratamento de Lock)
        id: tf_plan
        working-directory: infraestructure/03-aca
        env:
          TF_CLI_ARGS: "-input=false"
        run: |
          set -e

          echo "üìã Executando terraform plan..."

          # Define as vari√°veis CORRETAS baseadas no seu arquivo variables.tf
          ENVIRONMENT="dev"
          LOCATION="canadacentral"
          RESOURCE_GROUP="rg-aca-dev"
          ACR_LOGIN_SERVER="${{ env.ACR_LOGIN_SERVER }}"
          TF_BACKEND_RG="${{ needs.setup.outputs.tf_rg }}"
          TF_BACKEND_SA="${{ needs.setup.outputs.tf_sa }}"
          TF_BACKEND_CONTAINER="${{ needs.setup.outputs.tf_container }}"
          TF_BACKEND_SAS="${{ needs.setup.outputs.sas_token }}"
          ACA_SUBNET_ID="${{ env.ACA_SUBNET_ID }}"

          # Vari√°veis com valores padr√£o (n√£o precisam ser passadas se usar default)
          # Mas vamos defini-las explicitamente para clareza
          MIN_REPLICAS="1"
          MAX_REPLICAS="5"
          ENABLE_WORKER="false"
          KEY_VAULT_SKU="standard"
          SOFT_DELETE_DAYS="7"
          PURGE_PROTECTION="false"
          POSTGRESQL_HOST="postgresql-server.devops.internal"
          POSTGRESQL_USERNAME="postgres"

          # Fun√ß√£o para executar plan com tratamento de lock
          execute_plan() {
            local attempt=$1
            local use_lock=$2
            
            echo "Tentativa $attempt de executar plan (lock=$use_lock)..."
            
            # Constr√≥i o comando com APENAS as vari√°veis que existem
            local cmd="terraform plan"
            
            if [ "$use_lock" = "false" ]; then
              cmd="$cmd -lock=false"
            fi
            
            # Vari√°veis OBRIGAT√ìRIAS (sem default ou com default que queremos sobrescrever)
            cmd="$cmd -var environment=$ENVIRONMENT"
            cmd="$cmd -var location=$LOCATION"
            cmd="$cmd -var resource_group_name=$RESOURCE_GROUP"
            cmd="$cmd -var acr_login_server=$ACR_LOGIN_SERVER"
            cmd="$cmd -var tf_backend_resource_group=$TF_BACKEND_RG"
            cmd="$cmd -var tf_backend_storage_account=$TF_BACKEND_SA"
            cmd="$cmd -var tf_backend_container=$TF_BACKEND_CONTAINER"
            cmd="$cmd -var tf_backend_sas_token=$TF_BACKEND_SAS"
            
            # Vari√°veis OPCIONAIS (com default, mas podemos querer passar)
            if [ -n "$ACA_SUBNET_ID" ]; then
              cmd="$cmd -var aca_subnet_id=$ACA_SUBNET_ID"
            fi
            
            cmd="$cmd -input=false -detailed-exitcode"
            
            echo "Comando simplificado para debug..."
            
            # Executa plan
            $cmd 2>&1 | tee "plan_output_$attempt.txt"
            return ${PIPESTATUS[0]}
          }

          # Primeira tentativa com lock normal
          if execute_plan 1 "true"; then
            echo "‚úÖ Plan executado com sucesso"
            PLAN_EXIT_CODE=0
          else
            PLAN_EXIT_CODE=$?
            echo "‚ö†Ô∏è Plan falhou com c√≥digo: $PLAN_EXIT_CODE"
            
            # Verifica se foi por lock
            if grep -q "state lock" "plan_output_1.txt"; then
              echo "üîí Lock detectado, limpando..."
              
              # Extrai lock ID
              LOCK_ID=$(grep -Eo 'ID:\s+[a-z0-9\-]+' "plan_output_1.txt" | awk '{print $2}' | head -1)
              
              if [ -n "$LOCK_ID" ]; then
                echo "Removendo lock espec√≠fico: $LOCK_ID"
                terraform force-unlock -force "$LOCK_ID"
              fi
              
              # Limpa qualquer lock remanescente
              terraform force-unlock -force 2>/dev/null || true
              sleep 2
              
              # Segunda tentativa com lock=false
              echo "üîÑ Segunda tentativa com -lock=false..."
              if execute_plan 2 "false"; then
                echo "‚úÖ Plan executado com -lock=false"
                PLAN_EXIT_CODE=0
              else
                PLAN_EXIT_CODE=$?
                echo "‚ùå Plan falhou mesmo com -lock=false"
              fi
            fi
          fi

          # Processa resultado final
          case $PLAN_EXIT_CODE in
            0)
              echo "‚úÖ Nenhuma mudan√ßa necess√°ria"
              echo "CHANGES_DETECTED=false" >> $GITHUB_ENV
              ;;
            1)
              echo "‚ùå Erro no plan"
              echo "CHANGES_DETECTED=error" >> $GITHUB_ENV
              cat "plan_output_*.txt" | tail -20
              exit 1
              ;;
            2)
              echo "üìù Mudan√ßas detectadas"
              echo "CHANGES_DETECTED=true" >> $GITHUB_ENV
              ;;
            *)
              echo "‚ö†Ô∏è C√≥digo de sa√≠da inesperado: $PLAN_EXIT_CODE"
              echo "CHANGES_DETECTED=unknown" >> $GITHUB_ENV
              ;;
          esac

      - name: Clean Locks After Plan
        if: always()
        working-directory: infraestructure/03-aca
        run: |
          echo "üßπ Limpando locks ap√≥s plan..."
          terraform force-unlock -force 2>/dev/null || true
          echo "‚úÖ Limpeza conclu√≠da"

      - name: Terraform Apply - ACA (Condicional)
        if: github.event.inputs.tf_action == 'apply' && env.CHANGES_DETECTED == 'true'
        working-directory: infraestructure/03-aca
        env:
          TF_CLI_ARGS: "-input=false -auto-approve"
        run: |
          echo "üöÄ Aplicando mudan√ßas..."

          # Limpa locks antes do apply
          terraform force-unlock -force 2>/dev/null || true

          # Aplica com APENAS as vari√°veis que existem
          terraform apply \
            -var environment=dev \
            -var location=canadacentral \
            -var resource_group_name=rg-aca-dev \
            -var acr_login_server="${{ env.ACR_LOGIN_SERVER }}" \
            -var tf_backend_resource_group="${{ needs.setup.outputs.tf_rg }}" \
            -var tf_backend_storage_account="${{ needs.setup.outputs.tf_sa }}" \
            -var tf_backend_container="${{ needs.setup.outputs.tf_container }}" \
            -var tf_backend_sas_token="${{ needs.setup.outputs.sas_token }}" \
            -input=false -auto-approve

          echo "‚úÖ Aplica√ß√£o conclu√≠da"

      - name: Skip Apply (No Changes)
        if: github.event.inputs.tf_action == 'apply' && env.CHANGES_DETECTED != 'true'
        run: |
          echo "‚è≠Ô∏è Nenhuma mudan√ßa detectada - apply n√£o necess√°rio"
  # =====================================================
  # 5. DATABASE
  # =====================================================
  database:
    runs-on: ubuntu-latest
    needs: [setup, network]
    if: success()

    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3

      - name: Azure Login for Resource Query
        run: |
          az login \
            --service-principal \
            --username "${{ secrets.ARM_CLIENT_ID }}" \
            --password "${{ secrets.ARM_CLIENT_SECRET }}" \
            --tenant "${{ secrets.ARM_TENANT_ID }}"

          az account set --subscription "${{ secrets.ARM_SUBSCRIPTION_ID }}"

      - name: Get Network IDs from Azure
        run: |
          RG_NETWORK="rg-network-dev"
          VNET_NAME="vnet"
          SUBNET_NAME="snet-dev-devops-database"

          VNET_ID=$(az network vnet show \
            --resource-group "$RG_NETWORK" \
            --name "$VNET_NAME" \
            --query id -o tsv)

          DATABASE_SUBNET_ID=$(az network vnet subnet show \
            --resource-group "$RG_NETWORK" \
            --vnet-name "$VNET_NAME" \
            --name "$SUBNET_NAME" \
            --query id -o tsv)

          if [ -z "$VNET_ID" ] || [ -z "$DATABASE_SUBNET_ID" ]; then
            echo "Erro ao obter VNET_ID ou DATABASE_SUBNET_ID"
            exit 1
          fi

          echo "VNET_ID=$VNET_ID" >> $GITHUB_ENV
          echo "DATABASE_SUBNET_ID=$DATABASE_SUBNET_ID" >> $GITHUB_ENV

      - name: Terraform Init - Database
        working-directory: infraestructure/05-database
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ needs.setup.outputs.tf_rg }}" \
            -backend-config="storage_account_name=${{ needs.setup.outputs.tf_sa }}" \
            -backend-config="container_name=${{ needs.setup.outputs.tf_container }}" \
            -backend-config="key=database.tfstate" \
            -backend-config="sas_token=${{ needs.setup.outputs.sas_token }}" \
            -reconfigure \
            -input=false

      - name: Terraform Plan - Database
        working-directory: infraestructure/05-database
        run: |
          terraform plan \
            -var="subscription_id=${{ secrets.ARM_SUBSCRIPTION_ID }}" \
            -var="location=canadacentral" \
            -var="environment=dev" \
            -var="resource_group_name=rg-database-dev" \
            -var="vnet_id=$VNET_ID" \
            -var="database_subnet_id=$DATABASE_SUBNET_ID" \
            -var="db_name=psql-devops" \
            -var="postgres_version=15" \
            -var="sku_name=B_Standard_B1ms" \
            -var="storage_mb=32768" \
            -var="backup_retention_days=7" \
            -var="geo_redundant_backup_enabled=false" \
            -var="maintenance_window={day_of_week=0,start_hour=2,start_minute=0}" \
            -var="charset=UTF8" \
            -var="collation=en_US.utf8" \
            -var="zone=1" \
            -var="high_availability_mode=Disabled" \
            -var="tags={Environment=\"dev\",Project=\"devops-technical-test\",ManagedBy=\"Terraform\",Owner=\"Platform\"}" \
            -input=false

      - name: Terraform Apply - Database
        if: ${{ github.event.inputs.tf_action == 'apply' }}
        working-directory: infraestructure/05-database
        run: |
          terraform apply \
            -var="subscription_id=${{ secrets.ARM_SUBSCRIPTION_ID }}" \
            -var="location=canadacentral" \
            -var="environment=dev" \
            -var="resource_group_name=rg-database-dev" \
            -var="vnet_id=$VNET_ID" \
            -var="database_subnet_id=$DATABASE_SUBNET_ID" \
            -var="db_name=psql-devops" \
            -var="postgres_version=15" \
            -var="sku_name=B_Standard_B1ms" \
            -var="storage_mb=32768" \
            -var="backup_retention_days=7" \
            -var="geo_redundant_backup_enabled=false" \
            -var="maintenance_window={day_of_week=0,start_hour=2,start_minute=0}" \
            -var="charset=UTF8" \
            -var="collation=en_US.utf8" \
            -var="zone=1" \
            -var="high_availability_mode=Disabled" \
            -var="tags={Environment=\"dev\",Project=\"devops-technical-test\",ManagedBy=\"Terraform\",Owner=\"Platform\"}" \
            -auto-approve \
            -input=false

  # =====================================================
  # 6. BASTION
  # =====================================================
  bastion:
    runs-on: ubuntu-latest
    needs: [setup, network]

    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3

      - name: Azure Login
        run: |
          az login --service-principal \
            -u "${{ secrets.ARM_CLIENT_ID }}" \
            -p "${{ secrets.ARM_CLIENT_SECRET }}" \
            --tenant "${{ secrets.ARM_TENANT_ID }}"
          az account set -s "${{ secrets.ARM_SUBSCRIPTION_ID }}"

      - name: Get Bastion Subnet ID (with fallback)
        id: get_subnet
        run: |
          echo "üîç Obtendo Bastion Subnet ID..."

          # Tentar do output do network module
          NETWORK_SUBNET_ID="${{ needs.network.outputs.bastion_subnet_id }}"

          if [ -n "$NETWORK_SUBNET_ID" ]; then
            echo "‚úÖ Usando subnet do m√≥dulo network: $NETWORK_SUBNET_ID"
            SUBNET_ID="$NETWORK_SUBNET_ID"
          else
            echo "‚ö†Ô∏è  Subnet ID vazio no output. Buscando via Azure CLI..."
            
            # Buscar subnet manualmente
            SUBNET_ID=$(az network vnet subnet show \
              --resource-group "rg-network-dev" \
              --vnet-name "vnet" \
              --name "snet-dev-devops-bastion" \
              --query id -o tsv 2>/dev/null || echo "")
            
            if [ -z "$SUBNET_ID" ]; then
              echo "‚ùå Subnet n√£o encontrada! Criando..."
              # Se n√£o existir, criar
              SUBNET_ID=$(az network vnet subnet create \
                --resource-group "rg-network-dev" \
                --vnet-name "vnet" \
                --name "snet-dev-devops-bastion" \
                --address-prefixes "10.0.2.0/28" \
                --query id -o tsv)
            fi
            
            echo "‚úÖ Subnet ID via CLI: $SUBNET_ID"
          fi

          echo "Subnet ID final: $SUBNET_ID"
          echo "bastion_subnet_id=$SUBNET_ID" >> $GITHUB_OUTPUT
          echo "BASTION_SUBNET_ID=$SUBNET_ID" >> $GITHUB_ENV

      - name: Debug Network Outputs
        run: |
          echo "üîç Debugando outputs do m√≥dulo Network:"
          echo "VNET ID: '${{ needs.network.outputs.vnet_id }}'"
          echo "Bastion Subnet ID: '${{ needs.network.outputs.bastion_subnet_id }}'"

      - name: Terraform Init - Bastion
        working-directory: infraestructure/04-bastion
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ needs.setup.outputs.tf_rg }}" \
            -backend-config="storage_account_name=${{ needs.setup.outputs.tf_sa }}" \
            -backend-config="container_name=${{ needs.setup.outputs.tf_container }}" \
            -backend-config="key=bastion.tfstate" \
            -backend-config="sas_token=${{ needs.setup.outputs.sas_token }}" \
            -reconfigure \
            -input=false

      - name: Terraform Plan - Bastion
        working-directory: infraestructure/04-bastion
        run: |
          terraform plan \
            -var="subscription_id=${{ secrets.ARM_SUBSCRIPTION_ID }}" \
            -var="location=canadacentral" \
            -var="environment=dev" \
            -var="vnet_id=${{ needs.network.outputs.vnet_id }}" \
            -var="bastion_subnet_id=${{ steps.get_subnet.outputs.bastion_subnet_id }}" \
            -var="tf_backend_resource_group=${{ needs.setup.outputs.tf_rg }}" \
            -var="tf_backend_storage_account=${{ needs.setup.outputs.tf_sa }}" \
            -var="tf_backend_container=${{ needs.setup.outputs.tf_container }}" \
            -var="tf_backend_sas_token=${{ needs.setup.outputs.sas_token }}" \
            -input=false

      - name: Terraform Apply - Bastion
        if: ${{ github.event.inputs.tf_action == 'apply' }}
        working-directory: infraestructure/04-bastion
        run: |
          terraform apply \
            -var="subscription_id=${{ secrets.ARM_SUBSCRIPTION_ID }}" \
            -var="location=canadacentral" \
            -var="environment=dev" \
            -var="vnet_id=${{ needs.network.outputs.vnet_id }}" \
            -var="bastion_subnet_id=${{ steps.get_subnet.outputs.bastion_subnet_id }}" \
            -var="tf_backend_resource_group=${{ needs.setup.outputs.tf_rg }}" \
            -var="tf_backend_storage_account=${{ needs.setup.outputs.tf_sa }}" \
            -var="tf_backend_container=${{ needs.setup.outputs.tf_container }}" \
            -var="tf_backend_sas_token=${{ needs.setup.outputs.sas_token }}" \
            -auto-approve -input=false

  # =====================================================
  # 7. DEPLOY APP (ACA Version)
  # =====================================================
  deploy-app:
    runs-on: ubuntu-latest
    needs: [aca, database]
    timeout-minutes: 5

    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        run: |
          az login --service-principal \
            -u "${{ secrets.ARM_CLIENT_ID }}" \
            -p "${{ secrets.ARM_CLIENT_SECRET }}" \
            --tenant "${{ secrets.ARM_TENANT_ID }}"
          az account set -s "${{ secrets.ARM_SUBSCRIPTION_ID }}"

      - name: Get ACA Environment Info
        id: aca_info
        run: |
          echo "üîç Obtendo informa√ß√µes do ACA..."

          ACA_ENV_NAME=$(az containerapp env list \
            -g "rg-aca-dev" \
            --query "[0].name" -o tsv 2>/dev/null || echo "cae-dev")

          ACA_ENV_ID=$(az containerapp env show \
            -g "rg-aca-dev" \
            -n "$ACA_ENV_NAME" \
            --query id -o tsv 2>/dev/null || echo "")

          ACR_LOGIN_SERVER=$(az acr show \
            -g "rg-acr-dev" \
            -n "eijidevopsdevacr" \
            --query loginServer -o tsv 2>/dev/null || echo "myacr.azurecr.io")

          echo "ACA Environment: $ACA_ENV_NAME"
          echo "ACR Login Server: $ACR_LOGIN_SERVER"

          echo "aca_env_name=$ACA_ENV_NAME" >> $GITHUB_OUTPUT
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "ACA_ENV_NAME=$ACA_ENV_NAME" >> $GITHUB_ENV
          echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_ENV

      - name: Build and Push Docker Image to ACR
        run: |
          echo "üê≥ Buildando e enviando imagem Docker..."

          cd infraestructure/app

          # Login no ACR
          az acr login --name eijidevopsdevacr

          # Build da imagem
          docker build -t "${{ env.ACR_LOGIN_SERVER }}/fastapi-app:latest" .

          # Push para ACR
          docker push "${{ env.ACR_LOGIN_SERVER }}/fastapi-app:latest"

          echo "‚úÖ Imagem enviada para ACR: ${{ env.ACR_LOGIN_SERVER }}/fastapi-app:latest"

      - name: Deploy FastAPI to ACA
        run: |
          echo "üöÄ Deployando FastAPI no ACA..."

          # Verificar se o container app j√° existe
          if az containerapp show \
            -g "rg-aca-dev" \
            -n "fastapi-dev" &>/dev/null; then
            echo "üì¶ Atualizando container app existente..."
            
            az containerapp update \
              -g "rg-aca-dev" \
              -n "fastapi-dev" \
              --image "${{ env.ACR_LOGIN_SERVER }}/fastapi-app:latest" \
              --cpu 0.5 \
              --memory 1.0Gi \
              --min-replicas 1 \
              --max-replicas 3 \
              --set-env-vars \
                "APP_ENVIRONMENT=dev" \
                "APP_PORT=8000" \
              --revision-suffix "$(date +%Y%m%d-%H%M%S)"
              
          else
            echo "üÜï Criando novo container app..."
            
            az containerapp create \
              -g "rg-aca-dev" \
              -n "fastapi-dev" \
              --environment "${{ env.ACA_ENV_NAME }}" \
              --image "${{ env.ACR_LOGIN_SERVER }}/fastapi-app:latest" \
              --cpu 0.5 \
              --memory 1.0Gi \
              --min-replicas 1 \
              --max-replicas 3 \
              --ingress external \
              --target-port 8000 \
              --set-env-vars \
                "APP_ENVIRONMENT=dev" \
                "APP_PORT=8000"
          fi

          echo "‚úÖ FastAPI deployado no ACA"

      - name: Get Application URL and Info
        run: |
          echo "üåê Obtendo informa√ß√µes da aplica√ß√£o..."

          # Obter FQDN (URL p√∫blica)
          APP_URL=$(az containerapp show \
            -g "rg-aca-dev" \
            -n "fastapi-dev" \
            --query "properties.configuration.ingress.fqdn" -o tsv)

          APP_STATE=$(az containerapp show \
            -g "rg-aca-dev" \
            -n "fastapi-dev" \
            --query "properties.provisioningState" -o tsv)

          echo ""
          echo "=========================================="
          echo "üöÄ DEPLOY COMPLETO - AZURE CONTAINER APPS"
          echo "=========================================="
          echo ""
          echo "üìä Status: $APP_STATE"
          echo "üåê URL P√∫blica: https://$APP_URL"
          echo "üîó Health Check: https://$APP_URL/health"
          echo "üìù Swagger Docs: https://$APP_URL/docs"
          echo ""
          echo "üîß Comandos √∫teis:"
          echo "   Ver logs: az containerapp logs show -g rg-aca-dev -n fastapi-dev --follow"
          echo "   Ver status: az containerapp show -g rg-aca-dev -n fastapi-dev"
          echo "   Scale up: az containerapp update -g rg-aca-dev -n fastapi-dev --max-replicas 5"
          echo ""
          echo "‚è±Ô∏è  Tempo total: < 3 minutos"
          echo "üí∞ Custo estimado: ~$25/m√™s (Consumption plan)"
          echo ""
          echo "‚úÖ Pronto para testes!"

      - name: Test Application Health
        run: |
          echo "üß™ Testando aplica√ß√£o..."

          # Aguardar alguns segundos
          sleep 15

          # Obter URL
          APP_URL=$(az containerapp show \
            -g "rg-aca-dev" \
            -n "fastapi-dev" \
            --query "properties.configuration.ingress.fqdn" -o tsv)

          echo "Testando endpoint de health..."

          # Tentar curl com timeout
          for i in {1..5}; do
            echo "Tentativa $i..."
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "https://$APP_URL/health" --max-time 10 || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Health check OK (HTTP 200)"
              break
            else
              echo "‚ö†Ô∏è  Health check falhou: HTTP $HTTP_CODE"
              sleep 5
            fi
          done

  # =========================
  # 8. VALIDATE & SAVE OUTPUTS
  # =========================
  validate:
    runs-on: ubuntu-latest
    needs: [network, acr, aca, database, bastion, deploy-app]
    if: always()

    steps:
      - name: Show Results
        run: |
          echo "üìä Deployment Results:"
          echo "Network: ${{ needs.network.result }}"
          echo "ACR: ${{ needs.acr.result }}"
          echo "ACA: ${{ needs.aca.result }}"
          echo "Database: ${{ needs.database.result }}"
          echo "Bastion: ${{ needs.bastion.result }}"
          echo "Deploy App: ${{ needs.deploy-app.result }}"

          SUCCESS_COUNT=0
          TOTAL_COUNT=6

          if [ "${{ needs.network.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi
          if [ "${{ needs.acr.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi
          if [ "${{ needs.aca.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi
          if [ "${{ needs.database.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi
          if [ "${{ needs.bastion.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi
          if [ "${{ needs.deploy-app.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi

          echo ""
          echo "üéØ Summary: $SUCCESS_COUNT/$TOTAL_COUNT modules succeeded"

          if [ $SUCCESS_COUNT -eq $TOTAL_COUNT ]; then
            echo "‚úÖ All infrastructure modules deployed successfully!"
            echo ""
            echo "üèÅ DEPLOYMENT COMPLETE!"
            echo "Application is running on Azure Container Apps"
            echo "Cost: ~$25/month | Deployment time: < 10 minutes"
          else
            echo "‚ö†Ô∏è  Some modules failed. Check the logs above."
          fi
