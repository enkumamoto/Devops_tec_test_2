name: Terraform Infrastructure

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment name"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - staging
          - prod
      tf_action:
        description: "Terraform action"
        required: true
        default: "plan"
        type: choice
        options:
          - plan
          - apply

env:
  ENVIRONMENT: ${{ github.event.inputs.environment }}
  TF_ACTION: ${{ github.event.inputs.tf_action }}

  ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
  ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
  ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}

jobs:
  # =====================================================
  # 1. BACKEND BOOTSTRAP (Storage Account + Key)
  # =====================================================
  setup:
    runs-on: ubuntu-latest
    outputs:
      tf_rg: ${{ steps.backend.outputs.tf_rg }}
      tf_sa: ${{ steps.backend.outputs.tf_sa }}
      tf_container: ${{ steps.backend.outputs.tf_container }}
      sas_token: ${{ steps.backend.outputs.sas_token }}

    steps:
      - name: Azure Login (Service Principal)
        run: |
          az login \
            --service-principal \
            --username "${{ secrets.ARM_CLIENT_ID }}" \
            --password "${{ secrets.ARM_CLIENT_SECRET }}" \
            --tenant "${{ secrets.ARM_TENANT_ID }}"

          az account set --subscription "${{ secrets.ARM_SUBSCRIPTION_ID }}"

      - name: Create RG + Storage Account + Container
        id: backend
        run: |
          ENV="${{ github.event.inputs.environment }}"

          RG="rg-terraform-state-${ENV}"
          SA="tfstate${ENV}devops"
          CONTAINER="tfstate"
          LOCATION="canadacentral"

          az group create \
            --name "$RG" \
            --location "$LOCATION"

          az storage account create \
            --name "$SA" \
            --resource-group "$RG" \
            --location "$LOCATION" \
            --sku Standard_LRS \
            --kind StorageV2 \
            --https-only true \
            --allow-blob-public-access false

          SA_KEY=$(az storage account keys list \
            --resource-group "$RG" \
            --account-name "$SA" \
            --query "[0].value" -o tsv)

          az storage container create \
            --name "$CONTAINER" \
            --account-name "$SA" \
            --account-key "$SA_KEY" \
            --public-access off

          SAS_TOKEN=$(az storage container generate-sas \
            --name "$CONTAINER" \
            --account-name "$SA" \
            --account-key "$SA_KEY" \
            --permissions "rlwcd" \
            --expiry "2026-12-31" \
            --https-only \
            --output tsv)

          if [ -z "$SAS_TOKEN" ]; then
            echo "Erro: SAS_TOKEN est√° vazio. Verifique permiss√µes do SP no Storage Account."
            exit 1
          fi

          echo "::add-mask::$SAS_TOKEN"
          echo "tf_rg=$RG" >> $GITHUB_OUTPUT
          echo "tf_sa=$SA" >> $GITHUB_OUTPUT
          echo "tf_container=$CONTAINER" >> $GITHUB_OUTPUT
          echo "sas_token=$SAS_TOKEN" >> $GITHUB_OUTPUT

  # =====================================================
  # 2. NETWORK
  # =====================================================
  network:
    runs-on: ubuntu-latest
    needs: setup

    steps:
      - name: Checkout repository (with retry)
        uses: actions/checkout@v3
        continue-on-error: false

      - uses: hashicorp/setup-terraform@v3

      - name: Terraform Init - Network
        working-directory: infraestructure/01-network
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ needs.setup.outputs.tf_rg }}" \
            -backend-config="storage_account_name=${{ needs.setup.outputs.tf_sa }}" \
            -backend-config="container_name=${{ needs.setup.outputs.tf_container }}" \
            -backend-config="key=network.tfstate" \
            -backend-config="sas_token=${{ needs.setup.outputs.sas_token }}" \
            -reconfigure \
            -input=false

      - name: Terraform Plan - Network
        working-directory: infraestructure/01-network
        run: terraform plan -input=false

      - name: Terraform Apply - Network
        if: ${{ github.event.inputs.tf_action == 'apply' }}
        working-directory: infraestructure/01-network
        run: terraform apply -auto-approve -input=false

  # =====================================================
  # 3. ACR
  # =====================================================
  acr:
    runs-on: ubuntu-latest
    needs: setup

    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3

      - name: Terraform Init - ACR
        working-directory: infraestructure/02-acr
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ needs.setup.outputs.tf_rg }}" \
            -backend-config="storage_account_name=${{ needs.setup.outputs.tf_sa }}" \
            -backend-config="container_name=${{ needs.setup.outputs.tf_container }}" \
            -backend-config="key=acr.tfstate" \
            -backend-config="sas_token=${{ needs.setup.outputs.sas_token }}" \
            -reconfigure \
            -input=false

      - name: Terraform Plan - ACR
        working-directory: infraestructure/02-acr
        run: terraform plan -input=false

      - name: Terraform Apply - ACR
        if: ${{ github.event.inputs.tf_action == 'apply' }}
        working-directory: infraestructure/02-acr
        run: terraform apply -auto-approve -input=false

  # =====================================================
  # 4. AKS
  # =====================================================
  aks:
    runs-on: ubuntu-latest
    needs: [setup, network, acr]
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Azure Login
        run: |
          az login --service-principal \
            -u "${{ secrets.ARM_CLIENT_ID }}" \
            -p "${{ secrets.ARM_CLIENT_SECRET }}" \
            --tenant "${{ secrets.ARM_TENANT_ID }}"
          az account set -s "${{ secrets.ARM_SUBSCRIPTION_ID }}"

      - name: Clean Existing Key Vault (SEGURAN√áA)
        run: |
          echo "üßπ REMOVENDO Key Vault problem√°tico..."

          # Deletar Key Vault se existir
          az keyvault delete \
            --resource-group "rg-aks-dev" \
            --name "kv-aks-devops-dev" \
            --no-wait 2>/dev/null || echo "‚úÖ Key Vault n√£o existe ou j√° deletado"

          # Aguardar
          sleep 10

      - name: Force Unlock and Reset Terraform State
        run: |
          echo "üîì Resetando estado do Terraform..."

          # 1. Tentar quebrar lease se existir (comando CORRETO)
          az storage blob lease break \
            --account-name "${{ needs.setup.outputs.tf_sa }}" \
            --container-name "${{ needs.setup.outputs.tf_container }}" \
            --name "aks.tfstate" \
            --sas-token "${{ needs.setup.outputs.sas_token }}" \
            --auth-mode key 2>/dev/null || echo "‚úÖ Sem lease ativo"

          # 2. Deletar estado antigo
          az storage blob delete \
            --account-name "${{ needs.setup.outputs.tf_sa }}" \
            --container-name "${{ needs.setup.outputs.tf_container }}" \
            --name "aks.tfstate" \
            --sas-token "${{ needs.setup.outputs.sas_token }}" \
            --auth-mode key 2>/dev/null || echo "‚úÖ Estado n√£o existia"

          # 3. Criar estado vazio (m√©todo correto)
          echo '{"version": 1}' > empty_state.json
          az storage blob upload \
            --account-name "${{ needs.setup.outputs.tf_sa }}" \
            --container-name "${{ needs.setup.outputs.tf_container }}" \
            --name "aks.tfstate" \
            --file empty_state.json \
            --sas-token "${{ needs.setup.outputs.sas_token }}" \
            --auth-mode key \
            --content-type "application/json"
          rm -f empty_state.json

          echo "‚úÖ Estado resetado com sucesso!"

      - name: Get ACR ID
        id: get_acr
        run: |
          echo "üì¶ Obtendo ACR ID..."
          ACR_ID=$(az acr show \
            --resource-group "rg-acr-dev" \
            --name "eijidevopsdevacr" \
            --query id -o tsv 2>/dev/null || echo "")

          if [ -n "$ACR_ID" ]; then
            echo "‚úÖ ACR ID: $ACR_ID"
            echo "acr_id=$ACR_ID" >> $GITHUB_OUTPUT
            echo "ACR_ID=$ACR_ID" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è  ACR n√£o encontrado"
            echo "acr_id=" >> $GITHUB_OUTPUT
            echo "ACR_ID=" >> $GITHUB_ENV
          fi

      - name: Clean Local Terraform
        working-directory: infraestructure/03-aks
        run: |
          echo "üßπ Limpando local..."
          rm -rf .terraform .terraform.lock.hcl terraform.tfstate* *.backup

      - name: Modify Terraform to Avoid Key Vault Conflicts
        working-directory: infraestructure/03-aks
        run: |
          echo "üîß Modificando para evitar conflitos com Key Vault..."

          # 1. Renomear o Key Vault no terraform.tfvars
          if [ -f terraform.tfvars ]; then
            sed -i 's/key_vault_name = ""/key_vault_name = "kv-aks-devops-dev-NEW"/g' terraform.tfvars
            echo "‚úÖ Key Vault renomeado para 'kv-aks-devops-dev-NEW'"
          fi

          # 2. OU comente o Key Vault no c√≥digo (opcional)
          # sed -i 's/^resource "azurerm_key_vault"/# resource "azurerm_key_vault"/g' keyvault.tf
          # echo "‚úÖ Key Vault comentado temporariamente"

      - name: Terraform Init - AKS
        working-directory: infraestructure/03-aks
        run: |
          echo "üöÄ Inicializando Terraform..."
          terraform init \
            -backend-config="resource_group_name=${{ needs.setup.outputs.tf_rg }}" \
            -backend-config="storage_account_name=${{ needs.setup.outputs.tf_sa }}" \
            -backend-config="container_name=${{ needs.setup.outputs.tf_container }}" \
            -backend-config="key=aks.tfstate" \
            -backend-config="sas_token=${{ needs.setup.outputs.sas_token }}" \
            -reconfigure \
            -input=false

      - name: Terraform Plan - AKS
        working-directory: infraestructure/03-aks
        run: |
          echo "üìã Gerando plano..."

          # Usar vari√°veis inline (mais seguro)
          terraform plan \
            -var="environment=dev" \
            -var="location=canadacentral" \
            -var="resource_group_name=rg-aks-dev" \
            -var="aks_name=aks-devops" \
            -var="dns_prefix=aks-devops-dev" \
            -var="kubernetes_version=1.33.5" \
            -var="enable_acr_rbac=false" \
            -var="acr_id=${{ env.ACR_ID }}" \
            -var="key_vault_name=kv-aks-devops-dev-NEW" \
            -var="tf_backend_resource_group=${{ needs.setup.outputs.tf_rg }}" \
            -var="tf_backend_storage_account=${{ needs.setup.outputs.tf_sa }}" \
            -var="tf_backend_container=${{ needs.setup.outputs.tf_container }}" \
            -var="tf_backend_sas_token=${{ needs.setup.outputs.sas_token }}" \
            -input=false

      - name: Terraform Apply - AKS
        if: ${{ github.event.inputs.tf_action == 'apply' }}
        working-directory: infraestructure/03-aks
        timeout-minutes: 20
        run: |
          echo "‚ö° Aplicando AKS..."

          terraform apply \
            -var="environment=dev" \
            -var="location=canadacentral" \
            -var="resource_group_name=rg-aks-dev" \
            -var="aks_name=aks-devops" \
            -var="dns_prefix=aks-devops-dev" \
            -var="kubernetes_version=1.33.5" \
            -var="enable_acr_rbac=false" \
            -var="acr_id=${{ env.ACR_ID }}" \
            -var="key_vault_name=kv-aks-devops-dev-NEW" \
            -var="tf_backend_resource_group=${{ needs.setup.outputs.tf_rg }}" \
            -var="tf_backend_storage_account=${{ needs.setup.outputs.tf_sa }}" \
            -var="tf_backend_container=${{ needs.setup.outputs.tf_container }}" \
            -var="tf_backend_sas_token=${{ needs.setup.outputs.sas_token }}" \
            -auto-approve \
            -input=false

      - name: Configure ACR Access
        if: ${{ github.event.inputs.tf_action == 'apply' && env.ACR_ID != '' }}
        run: |
          echo "üîó Configurando acesso ACR..."
          sleep 30

          KUBELET_ID=$(az aks show \
            --resource-group "rg-aks-dev" \
            --name "aks-devops-dev-dev" \
            --query identityProfile.kubeletidentity.objectId -o tsv 2>/dev/null || echo "")

          if [ -n "$KUBELET_ID" ]; then
            echo "üîë Kubelet ID: $KUBELET_ID"
            az role assignment create \
              --assignee "$KUBELET_ID" \
              --role "AcrPull" \
              --scope "${{ env.ACR_ID }}" \
              || echo "‚úÖ Role j√° existe"
          else
            echo "‚ö†Ô∏è  N√£o foi poss√≠vel obter Kubelet ID"
          fi

  # =====================================================
  # 5. DATABASE
  # =====================================================
  database:
    runs-on: ubuntu-latest
    needs: [setup, network]
    if: success()

    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3

      - name: Azure Login for Resource Query
        run: |
          az login \
            --service-principal \
            --username "${{ secrets.ARM_CLIENT_ID }}" \
            --password "${{ secrets.ARM_CLIENT_SECRET }}" \
            --tenant "${{ secrets.ARM_TENANT_ID }}"

          az account set --subscription "${{ secrets.ARM_SUBSCRIPTION_ID }}"

      - name: Get Network IDs from Azure
        run: |
          RG_NETWORK="rg-network-dev"
          VNET_NAME="vnet"
          SUBNET_NAME="snet-dev-devops-database"

          VNET_ID=$(az network vnet show \
            --resource-group "$RG_NETWORK" \
            --name "$VNET_NAME" \
            --query id -o tsv)

          DATABASE_SUBNET_ID=$(az network vnet subnet show \
            --resource-group "$RG_NETWORK" \
            --vnet-name "$VNET_NAME" \
            --name "$SUBNET_NAME" \
            --query id -o tsv)

          if [ -z "$VNET_ID" ] || [ -z "$DATABASE_SUBNET_ID" ]; then
            echo "Erro ao obter VNET_ID ou DATABASE_SUBNET_ID"
            exit 1
          fi

          echo "VNET_ID=$VNET_ID" >> $GITHUB_ENV
          echo "DATABASE_SUBNET_ID=$DATABASE_SUBNET_ID" >> $GITHUB_ENV

      - name: Terraform Init - Database
        working-directory: infraestructure/05-database
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ needs.setup.outputs.tf_rg }}" \
            -backend-config="storage_account_name=${{ needs.setup.outputs.tf_sa }}" \
            -backend-config="container_name=${{ needs.setup.outputs.tf_container }}" \
            -backend-config="key=database.tfstate" \
            -backend-config="sas_token=${{ needs.setup.outputs.sas_token }}" \
            -reconfigure \
            -input=false

      - name: Terraform Plan - Database
        working-directory: infraestructure/05-database
        run: |
          terraform plan \
            -var="subscription_id=${{ secrets.ARM_SUBSCRIPTION_ID }}" \
            -var="location=canadacentral" \
            -var="environment=dev" \
            -var="resource_group_name=rg-database-dev" \
            -var="vnet_id=$VNET_ID" \
            -var="database_subnet_id=$DATABASE_SUBNET_ID" \
            -var="db_name=psql-devops" \
            -var="postgres_version=15" \
            -var="sku_name=B_Standard_B1ms" \
            -var="storage_mb=32768" \
            -var="backup_retention_days=7" \
            -var="geo_redundant_backup_enabled=false" \
            -var="maintenance_window={day_of_week=0,start_hour=2,start_minute=0}" \
            -var="charset=UTF8" \
            -var="collation=en_US.utf8" \
            -var="zone=1" \
            -var="high_availability_mode=Disabled" \
            -var="tags={Environment=\"dev\",Project=\"devops-technical-test\",ManagedBy=\"Terraform\",Owner=\"Platform\"}" \
            -input=false

      - name: Terraform Apply - Database
        if: ${{ github.event.inputs.tf_action == 'apply' }}
        working-directory: infraestructure/05-database
        run: |
          terraform apply \
            -var="subscription_id=${{ secrets.ARM_SUBSCRIPTION_ID }}" \
            -var="location=canadacentral" \
            -var="environment=dev" \
            -var="resource_group_name=rg-database-dev" \
            -var="vnet_id=$VNET_ID" \
            -var="database_subnet_id=$DATABASE_SUBNET_ID" \
            -var="db_name=psql-devops" \
            -var="postgres_version=15" \
            -var="sku_name=B_Standard_B1ms" \
            -var="storage_mb=32768" \
            -var="backup_retention_days=7" \
            -var="geo_redundant_backup_enabled=false" \
            -var="maintenance_window={day_of_week=0,start_hour=2,start_minute=0}" \
            -var="charset=UTF8" \
            -var="collation=en_US.utf8" \
            -var="zone=1" \
            -var="high_availability_mode=Disabled" \
            -var="tags={Environment=\"dev\",Project=\"devops-technical-test\",ManagedBy=\"Terraform\",Owner=\"Platform\"}" \
            -auto-approve \
            -input=false

  # =====================================================
  # 6. BASTION
  # =====================================================
  bastion:
    runs-on: ubuntu-latest
    needs: [setup, network]

    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3

      - name: Azure Login
        run: |
          az login --service-principal \
            -u "${{ secrets.ARM_CLIENT_ID }}" \
            -p "${{ secrets.ARM_CLIENT_SECRET }}" \
            --tenant "${{ secrets.ARM_TENANT_ID }}"
          az account set -s "${{ secrets.ARM_SUBSCRIPTION_ID }}"

      - name: Get Bastion Subnet ID (with fallback)
        id: get_subnet
        run: |
          echo "üîç Obtendo Bastion Subnet ID..."

          # Tentar do output do network module
          NETWORK_SUBNET_ID="${{ needs.network.outputs.bastion_subnet_id }}"

          if [ -n "$NETWORK_SUBNET_ID" ]; then
            echo "‚úÖ Usando subnet do m√≥dulo network: $NETWORK_SUBNET_ID"
            SUBNET_ID="$NETWORK_SUBNET_ID"
          else
            echo "‚ö†Ô∏è  Subnet ID vazio no output. Buscando via Azure CLI..."
            
            # Buscar subnet manualmente
            SUBNET_ID=$(az network vnet subnet show \
              --resource-group "rg-network-dev" \
              --vnet-name "vnet" \
              --name "snet-dev-devops-bastion" \
              --query id -o tsv 2>/dev/null || echo "")
            
            if [ -z "$SUBNET_ID" ]; then
              echo "‚ùå Subnet n√£o encontrada! Criando..."
              # Se n√£o existir, criar
              SUBNET_ID=$(az network vnet subnet create \
                --resource-group "rg-network-dev" \
                --vnet-name "vnet" \
                --name "snet-dev-devops-bastion" \
                --address-prefixes "10.0.2.0/28" \
                --query id -o tsv)
            fi
            
            echo "‚úÖ Subnet ID via CLI: $SUBNET_ID"
          fi

          echo "Subnet ID final: $SUBNET_ID"
          echo "bastion_subnet_id=$SUBNET_ID" >> $GITHUB_OUTPUT
          echo "BASTION_SUBNET_ID=$SUBNET_ID" >> $GITHUB_ENV

      - name: Debug Network Outputs
        run: |
          echo "üîç Debugando outputs do m√≥dulo Network:"
          echo "VNET ID: '${{ needs.network.outputs.vnet_id }}'"
          echo "Bastion Subnet ID: '${{ needs.network.outputs.bastion_subnet_id }}'"
          echo "AKS Subnet CIDR: '${{ needs.network.outputs.aks_subnet_address_prefixes }}'"

          # Se bastion_subnet_id estiver vazio, vamos obter via CLI
          if [ -z "${{ needs.network.outputs.bastion_subnet_id }}" ]; then
            echo "‚ö†Ô∏è  Bastion Subnet ID est√° vazio! Buscando via Azure CLI..."
            
            az login --service-principal \
              -u "${{ secrets.ARM_CLIENT_ID }}" \
              -p "${{ secrets.ARM_CLIENT_SECRET }}" \
              --tenant "${{ secrets.ARM_TENANT_ID }}"
            az account set -s "${{ secrets.ARM_SUBSCRIPTION_ID }}"
            
            BASTION_SUBNET_ID=$(az network vnet subnet show \
              --resource-group "rg-network-dev" \
              --vnet-name "vnet" \
              --name "snet-dev-devops-bastion" \
              --query id -o tsv 2>/dev/null || echo "")
            
            echo "Bastion Subnet ID via CLI: '$BASTION_SUBNET_ID'"
            echo "BASTION_SUBNET_ID=$BASTION_SUBNET_ID" >> $GITHUB_ENV
          fi

      - name: Terraform Init - Bastion
        working-directory: infraestructure/04-bastion
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ needs.setup.outputs.tf_rg }}" \
            -backend-config="storage_account_name=${{ needs.setup.outputs.tf_sa }}" \
            -backend-config="container_name=${{ needs.setup.outputs.tf_container }}" \
            -backend-config="key=bastion.tfstate" \
            -backend-config="sas_token=${{ needs.setup.outputs.sas_token }}" \
            -reconfigure \
            -input=false

      - name: Terraform Plan - Bastion
        working-directory: infraestructure/04-bastion
        run: |
          terraform plan \
            -var="subscription_id=${{ secrets.ARM_SUBSCRIPTION_ID }}" \
            -var="location=canadacentral" \
            -var="environment=dev" \
            -var="vnet_id=${{ needs.network.outputs.vnet_id }}" \
            -var="bastion_subnet_id=${{ steps.get_subnet.outputs.bastion_subnet_id }}" \
            -var="aks_subnet_cidr=${{ needs.network.outputs.aks_subnet_address_prefixes[0] }}" \
            -var="tf_backend_resource_group=${{ needs.setup.outputs.tf_rg }}" \
            -var="tf_backend_storage_account=${{ needs.setup.outputs.tf_sa }}" \
            -var="tf_backend_container=${{ needs.setup.outputs.tf_container }}" \
            -var="tf_backend_sas_token=${{ needs.setup.outputs.sas_token }}" \
            -input=false

      - name: Terraform Apply - Bastion
        if: ${{ github.event.inputs.tf_action == 'apply' }}
        working-directory: infraestructure/04-bastion
        run: |
          terraform apply \
            -var="subscription_id=${{ secrets.ARM_SUBSCRIPTION_ID }}" \
            -var="location=canadacentral" \
            -var="environment=dev" \
            -var="vnet_id=${{ needs.network.outputs.vnet_id }}" \
            -var="bastion_subnet_id=${{ steps.get_subnet.outputs.bastion_subnet_id }}" \
            -var="aks_subnet_cidr=${{ needs.network.outputs.aks_subnet_address_prefixes[0] }}" \
            -var="tf_backend_resource_group=${{ needs.setup.outputs.tf_rg }}" \
            -var="tf_backend_storage_account=${{ needs.setup.outputs.tf_sa }}" \
            -var="tf_backend_container=${{ needs.setup.outputs.tf_container }}" \
            -var="tf_backend_sas_token=${{ needs.setup.outputs.sas_token }}" \
            -auto-approve -input=false

  # =====================================================
  # 7. DEPLOY APP/K8S
  # =====================================================
  deploy-app:
    runs-on: ubuntu-latest # Runner padr√£o = R√ÅPIDO
    needs: [aks] # S√≥ depende do AKS estar pronto
    timeout-minutes: 8 # Timeout curto

    steps:
      - uses: actions/checkout@v4

      - name: Setup Helm (Super R√°pido)
        uses: azure/setup-helm@v3
        with:
          version: "latest"

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "latest"

      - name: Azure Login (Otimizado)
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.ARM_CLIENT_ID }}
          tenant-id: ${{ secrets.ARM_TENANT_ID }}
          subscription-id: ${{ secrets.ARM_SUBSCRIPTION_ID }}

      - name: Get AKS Credentials (R√°pido)
        uses: azure/aks-set-context@v3
        with:
          resource-group: rg-aks-dev
          cluster-name: aks-devops-dev-dev

      - name: Verify Cluster Access
        run: |
          echo "üîç Verificando acesso ao cluster..."
          kubectl cluster-info
          kubectl get nodes
          echo "‚úÖ Cluster acess√≠vel"

      - name: Build Custom Values for Helm (Din√¢mico)
        run: |
          echo "üìù Criando values.yaml customizado..."

          # Obter ACR login server dinamicamente
          ACR_LOGIN_SERVER=$(az acr show \
            -g "rg-acr-dev" \
            -n "eijidevopsdevacr" \
            --query loginServer -o tsv 2>/dev/null || echo "myacr.azurecr.io")

          cat > helm-values.yaml << EOF
          namespace: devops-app

          image:
            repository: ${ACR_LOGIN_SERVER}/fastapi-app
            tag: latest
            pullPolicy: IfNotPresent

          replicaCount: 2

          service:
            type: ClusterIP
            port: 80
            targetPort: 8000

          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 500m
              memory: 512Mi

          ingress:
            enabled: true
            className: nginx
            annotations:
              nginx.ingress.kubernetes.io/ssl-redirect: "false"
              nginx.ingress.kubernetes.io/proxy-body-size: "10m"
            hosts:
              - host: fastapi.devops.local
                paths:
                  - path: /
                    pathType: Prefix

          keyVault:
            enabled: false  # Para teste, desabilita CSI driver
          EOF

          echo "‚úÖ Values.yaml gerado:"
          cat helm-values.yaml

      - name: Deploy with Helm (Com Rollback Autom√°tico)
        run: |
          echo "üöÄ Deploy com Helm..."

          # 1. Criar namespace se n√£o existir
          kubectl create namespace devops-app 2>/dev/null || echo "Namespace j√° existe"

          # 2. Instalar/Atualizar com Helm
          helm upgrade --install fastapi \
            infraestructure/helm/fastapi \
            --namespace devops-app \
            --values helm-values.yaml \
            --atomic \           # Rollback autom√°tico se falhar
            --wait \             # Aguarda pods ficarem ready
            --timeout 5m \       # Timeout curto
            --cleanup-on-fail    # Limpa se falhar

          echo "‚úÖ Helm deploy conclu√≠do"

      - name: Verify Deployment
        run: |
          echo "üìä Verificando status..."

          # Aguardar pods ready
          sleep 10

          # Status dos recursos
          echo "=== PODS ==="
          kubectl get pods -n devops-app -o wide

          echo "=== SERVICES ==="
          kubectl get svc -n devops-app

          echo "=== INGRESS ==="
          kubectl get ingress -n devops-app

          echo "=== DEPLOYMENT STATUS ==="
          kubectl rollout status deployment/fastapi -n devops-app --timeout=60s

          # Testar acesso interno
          echo "=== TESTE DE ACESSO INTERNO ==="
          kubectl run -n devops-app test-curl --image=curlimages/curl -i --rm --restart=Never -- \
            curl -s -o /dev/null -w "%{http_code}" http://fastapi-service.devops-app.svc.cluster.local:80/health || echo "Teste falhou"

      - name: Get Application URL
        run: |
          echo "üåê URLs da aplica√ß√£o:"
          echo ""
          echo "1. Interno no cluster:"
          echo "   http://fastapi-service.devops-app.svc.cluster.local"
          echo ""
          echo "2. Via Ingress (externo):"
          echo "   http://fastapi.devops.local"
          echo ""
          echo "3. Para testar localmente (port-forward):"
          echo "   kubectl port-forward -n devops-app svc/fastapi-service 8080:80"
          echo "   Acesse: http://localhost:8080"
          echo ""
          echo "‚úÖ Deploy completo em $(date +%H:%M:%S)"

  # =========================
  # 8. VALIDATE & SAVE OUTPUTS
  # =========================
  validate:
    runs-on: ubuntu-latest
    needs: [network, acr, aks, database, bastion, deploy-app]
    if: always()

    steps:
      - name: Show Results
        run: |
          echo "üìä Deployment Results:"
          echo "Network: ${{ needs.network.result }}"
          echo "ACR: ${{ needs.acr.result }}"
          echo "AKS: ${{ needs.aks.result }}"
          echo "Database: ${{ needs.database.result }}"
          echo "Bastion: ${{ needs.bastion.result }}"
          echo "Deploy App: ${{ needs.deploy-app.result }}"

          SUCCESS_COUNT=0
          TOTAL_COUNT=6

          if [ "${{ needs.network.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi
          if [ "${{ needs.acr.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi
          if [ "${{ needs.aks.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi
          if [ "${{ needs.database.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi
          if [ "${{ needs.bastion.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi
          if [ "${{ needs.deploy-app.result }}" = "success" ]; then SUCCESS_COUNT=$((SUCCESS_COUNT + 1)); fi

          echo ""
          echo "üéØ Summary: $SUCCESS_COUNT/$TOTAL_COUNT modules succeeded"

          if [ $SUCCESS_COUNT -eq $TOTAL_COUNT ]; then
            echo "‚úÖ All infrastructure modules deployed successfully!"
          else
            echo "‚ö†Ô∏è  Some modules failed. Check the logs above."
          fi
